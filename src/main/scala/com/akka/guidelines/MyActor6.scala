package com.akka.guidelines

import akka.actor.{Actor, ActorRef}
import com.akkahttp.examples.WebServer1.Item


import scala.collection.immutable.Queue
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global

/***
  * Guideline6 : SHOULD do back-pressure
  * A correct, worry-free design does this:
    workers must signal demand (i.e. when they are ready for processing more items)
    the producer must produce items only when there is demand from workers
  */



/**
  * Message used by the producer for continuously polling the
  * data-source, while in the polling state.
  */
case object PollTick

/**
  * State machine with 2 states:
  *
  *  - Standby, which means there probably is a pending queue of items waiting to
  *    be sent downstream, but the actor is waiting for demand to be signaled
  *
  *  - Polling, which means that there is demand from downstream, but the
  *    actor is waiting for items to happen
  *
  * IMPORTANT: as a matter of protocol, this actor must not receive multiple
  *            Continue events - downstream Router should wait for an item
  *            to be delivered before sending the next Continue event to this
  *            actor.
  */

case class DataSource(items: List[Item])
object DataSource{
  implicit class DataSourceExtenion(ds: DataSource) {
    def next(): Option[Item] = ds.items.headOption
  }
}
class Producer(source: DataSource, router: ActorRef) extends Actor {

  override def preStart(): Unit = {
    super.preStart()
    // this is ignoring another rule I care about (actors should evolve
    // only in response to external messages), but we'll let that be
    // for didactical purposes
    context.system.scheduler.schedule(1.second, 1.second, self, PollTick)
  }

  // actor starts in standby state
  def receive = standby

  def standby: Receive = {
    case PollTick =>
    // ignore

    case Continue =>
      // demand signaled, so try to send the next item
      source.next() match {
        case None =>
          // no items available, go in polling mode
          context.become(polling)

        case Some(item) =>
          // item available, send it downstream,
          // and stay in standby state
          router ! item
      }
  }

  def polling: Receive = {
    case PollTick =>
      source.next() match {
        case None =>
          () // ignore - stays in polling
        case Some(item) =>
          // item available, demand available
          router ! item
          // go in standby
          context.become(standby)
      }
  }
}

/**
  * The Router is the middleman between the upstream Producer and
  * the Workers, keeping track of demand (to keep the producer simpler).
  *
  * NOTE: the protocol of Producer needs to be respected - so
  *       we are signaling a Continue to the upstream Producer
  *       after and only after a item has been sent downstream
  *       for processing to a worker.
  */
class Router(producer: ActorRef) extends Actor {
  var upstreamQueue = Queue.empty[Item]
  var downstreamQueue = Queue.empty[ActorRef]

  override def preStart(): Unit = {
    super.preStart()
    // signals initial demand to upstream
    producer ! Continue
  }

  def receive = {
    case Continue =>
      // demand signaled from downstream, if we have items to send
      // then send, otherwise enqueue the downstream consumer
      if (upstreamQueue.isEmpty) {
        downstreamQueue = downstreamQueue.enqueue(sender)
      }
      else {
        // no need to signal demand upstream, since we've got queued
        // items, just send them downstream
        val (item, newQueue) = upstreamQueue.dequeue
        upstreamQueue = newQueue
        sender ! item

        // signal demand upstream for another item
        producer ! Continue
      }

    case item: Item =>
      // item signaled from upstream, if we have queued consumers
      // then signal it downstream, otherwise enqueue it
      if (downstreamQueue.isEmpty) {
        upstreamQueue = upstreamQueue.enqueue(item)
      }
      else {
        val (consumer, newQueue) = downstreamQueue.dequeue
        downstreamQueue = newQueue
        consumer ! item

        // signal demand upstream for another item
        producer ! Continue
      }
  }
}

class Worker(router: ActorRef) extends Actor {
  override def preStart(): Unit = {
    super.preStart()
    // signals initial demand to upstream
    router ! Continue
  }

  def receive = {
    case item: Item =>
      process(item)
      router ! Continue
  }


  def process(item: Item) = ???
}
